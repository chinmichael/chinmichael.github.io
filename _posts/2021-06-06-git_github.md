---
title: "[Git 기초] Github Clone, Fetch, Pull, Push"
excerpt: ""

categories: 
    - Git
tags:
    - [Git, Github, Git 명령어]

toc: true
toc_label: "목차"
toc_icon: "indent"
toc_sticky: true

date: 2021-06-06
last_modified_at: 2021-06-06
---
Git은 VCS(Version Control System) 중 DVCS(Distributed 분산버전관리시스템)에 속합니다.   

DVCS와 CVCS(Central 중앙집중식)는 둘 다 효과적인 협업관리를 위해 버전관리 데이터를 로컬이 아닌 
외부서버에 둬서 각각의 작업 클라이언트가 공유할 수 있게 합니다.   

물론 둘의 차이점도 존재하는데 CVCS의 경우 버전 데이터 자체는 중앙 서버에만 두고 클라이언트는 각 
작업의 최신 스냅샷을 받아서 사용(Checkout)합니다. 덕분에 전체 작업 관리 및 통제에는 효과적이지만
중앙 서버에 문제가 생기면 전체 프로젝트에 큰 차질이 생길 수 있습니다.   

이와는 반대로 DVCS의 경우는 공유된 작업의 모든 데이터(스냅샷, 히스토리 등)가 원격 저장소 서버와 
각 클라이언트 로컬에 모두 똑같이 저장됩니다. 말그대로 똑같이 복제(Clone)하여 작업하는 방식이기에 한쪽이라도 
무사하다면 프로젝트는 보존될 수 있습니다.   

<br/>

***
오늘 포스팅에서는 이런 DVCS의 협업기능을 살리기 위한 Git 원격저장소 사이트인 Github의 기본적인 
사용법과 명령어를 말씀드리도록 하겠습니다.   

그 이전에 만약 Github에 계정이 없으시면 아래 링크를 통하여 하나 만드시는걸 추천 드립니다. 기본적인
버전관리, 오픈소스 코드 공유 뿐 아니라 이 블로그 같은 호스팅 서비스, utterance 댓글 뿐 아니라 
Github와 계정연동이 가능한 개발자 사이트도 많아지고 있어요.......   

> * [Github 홈페이지](https://github.com/)   

<br/>

## 1. 원격저장소 Clone, Remote, Push하기
우선 Github에서 데이터를 공유 및 저장할 원격 저장소(Repository)에 들어갑니다. 만약 새로 생성해야 
한다면 로그인 후의 화면에서 좌측 Repositories 항목이나 계정 메뉴의 Your Repositories로 들어가 
초록색 'New'버튼으로 새 Respository를 생성합니다.   

몇가지 옵션을 간단히 말씀드리면 Public, Private는 말그대로 저장소 공개, 비공개입니다. 앞으로 업데이트가 
어떻게 될지 모르나 Private 설정으로 팀원 공유나 Github Pages 호스팅을 하려면 유료회원으로 전환해야 합니다.   

`.gitignore`, `README` 파일은 저장소를 만들때 생성하셔도 되지만 프로젝트 루트 폴더에서 두 파일을 
생성해 올리셔도 됩니다. 개인적으로 편하신 쪽을 택하시면 됩니다. (전 후자입니다.) `README`파일은 `.md`
마크다운 파일로 하여 작성하시면 됩니다. `.gitignore`은 [이전 포스팅](/git/git_commit/#1-git-%ED%8F%B4%EB%8D%94-%EC%83%9D%EC%84%B1-%EB%B0%8F-3%EA%B0%80%EC%A7%80-%EC%83%81%ED%83%9C)에서 간단히 이야기했고 마크다운 
문법은 추후 블로그 제작 포스팅을 할 때 올리도록 하겠습니다.   

그리고 이렇게 생성한 혹은 이미 있는 Repository의 'Code' 카테고리에서 녹색의 'Code ↓'버튼을 눌러 로컬과 
연동할 주소를 복사합니다. (상황에 따라 다르지만 보통 HTTPS의 URL을 받습니다.)

<br/>

***
우선 이미 Github 저장소에 올라와 있는 모든 데이터를 로컬의 비어있는 폴더로 옮기는 경우는 다음 명령으로 
위에서 받은 주소를 지정합니다.
```
git clone 저장소주소
```
위 'Code ↓'버튼에서 주소가 아니라 `.zip`으로 파일들을 받아올 수 있지만, 이렇게 `clone`명령어로 받아오는 것이 
Git의 커밋 히스토리까지 모두 가져올 수 있어 협업에서는 더 나을 수 있습니다.

<br/>

***
로컬의 작업내역을 비어있는 원격저장소에 업데이트 하거나, 합치게 된다면 우선 `remote`로 원격저장소와 로컬을
연결합니다. 우선 아래 명령으로 연결이 되어 있는지 확인합니다.
```
git remote
```
그리고 연결된(`remote`된) 저장소가 없다면 다음과 같이 지정할 수 있습니다.
```
git remote add 저장소명 저장소주소
git remote add origin 저장소주소
```
`origin`은 로컬에서 임의 지정한 원격저장소 이름입니다. 위 명령으로 지정시 다른 이름으로 할 수는 있지만 보통 
'origin'으로 명명합니다.   

만약 원격저장소 이름을 바꾸거나 연결을 끊을려면 다음 명령어를 사용하시면 됩니다.   
이름 변경
```
git remote rename 원래이름 변경할이름
```
연결 끊기
```
git remote remove 저장소명
```

<br/>

***
이제 `remote`된 원격저장소가 비었다면 아래 명령으로 로컬의 커밋된 데이터들을 바로 올릴 수 있습니다.
```
git push 원격저장소명 커밋할브랜치명 
```
보통 원격저장소명을 'origin'으로, 개인작업이나 최초 업데이트에는 'master' 브랜치를 지정하므로 다음과 
같이 됩니다. 해당 브랜치로 계속 `push`를 한다면 `-u`옵션을 넣어 다음 `push`부터 인자생략이 가능해 
`git push`만 입력하면 업데이트가 가능합니다.
```
git push origin master
git push -u origin master
```
만약 중간에 계정 정보를 묻는 경우는 Github ID와 PW을 입력하시면 됩니다.

<br/>

***
### 참조. Git Credential 
만약 매번 계정 정보를 묻는 경우 다음과 같이 Git의 Credential(인증정보) 기능으로 저장 및 자동입력을 
시킬 수 있습니다. `cache`모드의 경우 메모리에서 15분만 유효하고 `store`모드는 계속 유지되지만 파일에 
저장되기 때문에 보안성이 떨어집니다.   

`cache`모드
```
git config --global credential.helper cache
```
`store`모드
```
git config --global credential.helper 'store --file 저장할경로'
```

<br/>

## 2. Fetch Pull 하기
위에서의 `push`는 비어있는 원격저장소나 하나의 로컬에서만 이뤄지는 개인 작업에서는 문제가 없지만, 
협업과 같은 상황에서는 원격저장소의 업데이트 이력이 현재 자신의 로컬과 맞지 않을 수 있습니다.   

따라서 로컬의 `master`브랜치와 원격저장소의 `origin/master`(저장소명/브랜치명)은 당연히 별개의 존재이며, 
이런 로컬의 '브랜치'와 '저장소/브랜치'의 최신내역이 `merge`된 상태에서 `push`가 가능해집니다.   

이런 원격저장소와 로컬의 버전을 맞추는 작업은 `fetch`와 `pull`로 가능하며 여기서는 원격저장소명은 
'origin'으로 작업브랜치명은 'master'로 가정하고 명령어를 소개하겠습니다.   

<br/>

***
로컬의 브랜치(`master`)로 원격저장소 해당 브랜치(`origin/master`)의 최신내역을 `merge`하는 것은 
다음과 같이 `pull`명령을 통해 한번에 처리가 가능합니다.
```
git pull 저장소명 브랜치명
git pull origin master
``` 
물론 내부적으로 `merge`작업이기 때문에 `충돌(conflict)` 상황이 발생할 수 있어 이 경우 기존 충돌처리를 
해서 다시 커밋을 해줘야 합니다.   

이렇게 `pull` 작업을 진행한 후에는 그사이 다른 로컬에서 새로운 `push`를 하지 않았다는 전제하에 이제 
원격저장소에 `push`가 가능합니다.

<br/>

***
`pull`이 한번에 병합처리까지 하는 것이라면 `fetch`는 원격저장소에 새로 `push`된 데이터를 받아오기만 
하는 작업입니다. 데이터만 받아오기에 `FETCH_HEAD`로 이동 가능한 임시 참조를 생성해 사용합니다.
```
git fetch
```
추가, 변경된 데이터는 `git status` 명령어로 내역을 확인할 수 있습니다.   

어차피 `push`를 진행하기 위해서는 업데이트된 부분을 `merge`해야 합니다. 이 작업은 위에서처럼 `pull`을 
쓰거나 병합을 진행할 브랜치에 위에서 언급한 `FETCH_HEAD`를 `merge`합니다.
```
git pull origin master
```
혹은 `master`브랜치로 `checkout`한 뒤 (`git checkout master`)
```
git merge FETCH_HEAD
```
즉 `pull`은 `fetch` + `merge`라고 생각할 수 있습니다.

<br/>

## 3. Fetch와 원격저장소의 Branch
위 설명에서 `fetch`를 통해 원격저장소의 데이터를 받아온다고 했습니다. 하지만 조금 더 정확히 이야기하면 `fetch`와 
내부적으로 `fetch`를 사용하는 `pull`은 현재 로컬에서 `checkout`된 브랜치에 해당하는 원격저장소의 브랜치 데이터를 
가져옵니다.   

`push`는 `git push 저장소명 브랜치명`인 만큼 작업을 올릴 브랜치 정보만 맞춰지면 `push`처리가 가능하지만, 혹시 
원격저장소의 모든 브랜치 정보를 가져오려면 `fetch`가 아니라 다음 명령을 사용합니다.
```
git remote update
```
물론 이 경우도 `fetch`처럼 병합까지 바로 진행되지는 않습니다.   

<br/>

***
그리고 만약에 원격저장소에는 존재하지만, 로컬에는 존재하지 않는 브랜치를 받아와 추가하려면 다음과 같이 하시면
됩니다.   

우선 `fetch`나 위의 `remote update`를 사용한 뒤 다음 명령으로 원격저장소 브랜치들을 확인 가능합니다.
```
git branch -a
git branch -r
```
`git branch`는 현재 로컬의 브랜치들을 확인 할 수 있는 명령어입니다. 여기에 옵션으로 `-a`를 입력하면 로컬과 
업데이트된 원격저장소의 브랜치들을 확인할 수 있고, `-r` 혹은 `--remote`로 원격저장소의 브랜치만 체크도 가능합니다.   

그리고 다음 명령어로 로컬에 해당 원격브랜치의 정보를 받아와 이동할 수 있습니다.
```
git checkout -t 저장소명/브랜치명
git checkout -b 로컬브랜치명 저장소명/브랜치명
```
`-t`옵션을 주면 로컬에서의 브랜치명을 지정하지 않아도 원격저장소의 것과 동일하게 생성됩니다. 옵션을 주지 
않으면 똑같이 하거나 아예 새롭게 지정도 되지만 가능한 똑같이 지정하는 편이 좋습니다.

<br/>

***
참고로 더이상 필요가 없어진 원격의 브랜치를 삭제할 경우 다음 명령으로 처리할 수 있습니다.
```
git push -d 저장소명/브랜치명
```

<br/>

이제까지 Git의 기본적인 사용법을 정리해보았습니다. 여러모로 부족했던 설명 읽어주셔서 감사합니다. 추가적으로 
알아가야할 부분은 공부 후에 차차 추가해 나가도록 하겠습니다.
   
<br/>

언제나 읽어주셔서 감사합니다.^^  

***

```
개인 공부용 블로그입니다.
잘못된 부분에 언제든지 댓글이나 메일로 지적해주시면 감사하겠습니다.
```